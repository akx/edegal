from django.core.validators import RegexValidator
from django.db import models
from django.db.models import Q

from mptt.models import MPTTModel, TreeForeignKey

from .utils import slugify, pick_attrs


validate_slug = RegexValidator(
    regex=r'[a-z0-9-]+',
    message= 'Tekninen nimi saa sisältää vain pieniä kirjaimia, numeroita sekä väliviivoja.'
)

validate_path = RegexValidator(
    regex=r'[a-z0-9-/]+',
    message='Polku saa sisältää vain pieniä kirjaimia, numeroita, väliviivoja sekä kauttaviivoja.'
)


class CommonFields(object):
    path = dict(
        max_length=1023,
        validators=[validate_path],
        verbose_name='Polku',
        help_text='Polku määritetään automaattisesti teknisen nimen perusteella.',
    )

    slug = dict(
        blank=True, # actually not, but autogenerated anyway
        max_length=63,
        validators=[validate_slug],
        verbose_name='Tekninen nimi',
        help_text='Tekninen nimi eli "slug" näkyy URL-osoitteissa. Sallittuja '
            'merkkejä ovat pienet kirjaimet, numerot ja väliviiva. Jos jätät teknisen nimen tyhjäksi, '
            'se generoidaan automaattisesti otsikosta. Jos muutat teknistä nimeä julkaisun jälkeen, '
            'muista luoda tarvittavat uudelleenojaukset.',
    )

    title = dict(
        max_length=1023,
        verbose_name='Otsikko',
        help_text='Otsikko näytetään automaattisesti sivun ylälaidassa sekä valikossa. Älä lisää erillistä pääotsikkoa sivun tekstiin.',
    )

    description = dict(
        verbose_name='Kuvaus',
        help_text='Näkyy mm. hakukoneille sekä RSS-asiakasohjelmille.',
        blank=True,
        default='',
    )


class Album(MPTTModel):
    slug = models.CharField(**CommonFields.slug)
    parent = TreeForeignKey('self',
        null=True,
        blank=True,
        related_name='subalbums',
        db_index=True,
        verbose_name='Yläalbumi',
        help_text='Tämä albumi luodaan valitun albumin alaisuuteen. Juurialbumilla ei ole yläalbumia.'
    )
    path = models.CharField(**CommonFields.path)

    title = models.CharField(**CommonFields.title)
    description = models.TextField(**CommonFields.description)

    def as_dict(self):
        return pick_attrs(self,
            'slug',
            'path',
            'title',
            'description',

            breadcrumb=[ancestor._make_breadcrumb() for ancestor in self.get_ancestors()],
            subalbums=[subalbum._make_subalbum() for subalbum in self.subalbums.all()],
            pictures=[picture.as_dict() for picture in self.pictures.all()],
        )

    def _make_breadcrumb(self):
        return pick_attrs(self,
            'path',
            'title',
        )

    def _make_subalbum(self):
        return pick_attrs(self,
            'path',
            'title',
            # TODO thumbnail
        )

    def _make_path(self):
        if self.parent is None:
            return '/'
        else:
            # XX ugly
            pth = self.parent.path + '/' + self.slug
            if pth.startswith('//'):
                pth = pth[1:]
            return pth

    def save(self, *args, **kwargs):
        if self.title and not self.slug:
            if self.parent:
                self.slug = slugify(self.title)
            else:
                self.slug = '-root-album'

        if self.slug:
            self.path = self._make_path()

        return_value = super(Album, self).save(*args, **kwargs)

        # In case path changed, update child pages' paths.
        # TODO prevent parent loop somewhere else
        for subalbum in self.subalbums.all():
            subalbum.save()
        for picture in self.pictures.all():
            picture.save()

    @classmethod
    def get_album_by_path(cls, path, **extra_criteria):
        q = Q(path=path) | Q(pictures__path=path)

        if extra_criteria:
            q = q.filter(extra_criteria)

        return cls.objects.distinct().prefetch_related('pictures').get(q)

    def __str__ (self):
        return self.title

    class Meta:
        verbose_name = 'Albumi'
        verbose_name_plural = 'Albumit'
        unique_together = [('parent', 'slug')]


class Picture(models.Model):
    slug = models.CharField(**CommonFields.slug)
    album = models.ForeignKey(Album, related_name='pictures')
    path = models.CharField(db_index=True, **CommonFields.path)

    title = models.CharField(**CommonFields.title)
    description = models.TextField(**CommonFields.description)

    def as_dict(self):
        return pick_attrs(self,
            'path',
            'title',
            'description',
            media=[medium.as_dict() for medium in self.media.all()],
            # TODO thumbnail
        )

    def _make_path(self):
        assert self.album
        return self.album.path + '/' + self.slug

    def get_original(self):
        return self.media.get(spec=None)

    def save(self, *args, **kwargs):
        if self.title and not self.slug:
            self.slug = slugify(self.title)

        if self.slug:
            self.path = self._make_path()

        return super(Picture, self).save(*args, **kwargs)

    def __str__ (self):
        return self.title

    class Meta:
        verbose_name = 'Kuva'
        verbose_name_plural = 'Kuvat'
        unique_together = [('album', 'slug')]


class MediaSpec(models.Model):
    max_width = models.PositiveIntegerField()
    max_height = models.PositiveIntegerField()
    quality = models.PositiveIntegerField()

    def __str__(self):
        return "{width}x{height}q{quality}".format(
            width=self.max_width,
            height=self.max_height,
            quality=self.quality,
        )


class Media(models.Model):
    picture = models.ForeignKey(Picture, related_name='media')
    width = models.PositiveIntegerField(default=0)
    height = models.PositiveIntegerField(default=0)
    src = models.ImageField(
        null=True,
        max_length=255,
        width_field='width',
        height_field='height',
    )
    spec = models.ForeignKey(MediaSpec, null=True, blank=True)

    def as_dict(self):
        return pick_attrs(self,
            'width',
            'height',
            src=self.src.url,
        )

    @property
    def is_original(self):
        return self.spec is None

    def get_canonical_path(self):
        """
        Returns the canonical path of this medium. For originals, this is where the file would be stored
        unless in-place mode was used.

        Originals: /pictures/path/to/album/mypicture.jpg
        Previews: /pictures/path/to/album/mypicture/640x480q60.jpg
        """

        if self.is_original:
            base_dir = 'pictures'
            postfix = ''
        else:
            base_dir = 'previews'
            postfix = '/' + str(self.spec)

        # TODO hardcoded jpeg
        return "{base_dir}{path}{postfix}.jpg".format(
            base_dir=base_dir,
            path=self.picture.path,
            postfix=postfix,
        )
